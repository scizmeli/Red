---
title: "Introduction to programming with R"
output: html_notebook
---

Tutorial : Introduction to R
Servet Ahmet Çizmeli, [PranaGEO Ltd.](https://pranageo.com)


This tutorial has been compiled by slightly modifying a subset of the contents of the following documents : 

An Introduction to R http://cran.r-project.org/doc/manuals/R-intro.pdf
R Data Import/Export http://cran.r-project.org/doc/manuals/R-data.pdf
R Installation and Administration http://cran.r-project.org/doc/manuals/R-admin.pdf

## Getting help
R comes with extensive documentation. For example, to read the help of the function *lgamma*, type :

```{r}
help(lgamma)
```

or 

```{r}
?lgamma
```

On most R installations help is available in HTML format by running :


```{r}
help.start()
```

The vertical arrow keys on the keyboard ⇓⇑ can be used to scroll forward and backward through a command history.

## Basic tools to interact with R
### Special variable .Last.value
The special variable *.Last.value* prints the results of the last valid expression :
```{r}
a=1.2 
1/a 
```
and access the contents of *.Last.value* :
```{r}
.Last.value 
```

### Source and sink
The file *commands.R* contains some R code. This is an R script file. Let us have a look at the contents of it :
```{r}
cat(readLines("commands.R"), sep="\n") 
```

The run the R commands that are contained within a script file, use the function *source()* : 
```{r}
source("commands.R")
```

It is possible to redirect the output of running commands and functions into a text file on disk using *sink()*. The function *sink()* will divert all subsequent output from the console to an external file, ‘record.lis’. The second call will close the file.
```{r}
sink("record.lis")
i <- 1:30
outer(i, i, "*")
sink()
```

To make sure the file exists on the filesystem : 
```{r}
list.files(".","record")
```

The first variable to function *list.files()* is the directory to search under (here, the current working directory as denoted by "."). The second argument is the regular expressions (Regex) pattern for searching the file. For more information on Regex, refer to this course by [Gloria Li and Jenny Bryan](http://stat545.com/block022_regular-expression.html).

Note that Regex is an advanced, hairy subject. If you are more comfortable with simple shell globing, you can use *glob2rx()* to obtain the same results :
```{r}
list.files(".",glob2rx("rec*"))
```

To obtain the size of the file in bytes, use the utility function "file.size()":
```{r}
file.size("record.lis")
```


### Current working directory
In the above examples, interacted with files the operating system's filesystem from R but we did not provide any file path to find them. R was able to find the file because it was located in the **current directory**. To get the current directory, use *getwd()*:
```{r}
getwd()
```
and to change it, use setwd()
```{r eval=FALSE}
setwd("some_existing_sub_directory")
```

## Variables and native data types in R
The entities that R creates and manipulates are known as objects. These may be variables, arrays of numbers, character strings, functions, or more general structures built from such components. During an R session, objects are created and stored by name inside the global environment. The R commands *objects()* and *ls()* save the same purpose of listing the name of objects (variables) available in the global workspace. :

```{r}
objects()
```

lists the objects currently stored in the memory of R (which is also called, workspace). To remove objects from the memory, use the function *rm()* :

```{r}
rm(a, i)
ls()
```

## Numbers and vectors
The following command makes a concatenation of scalar numbers using the function “c” to form a vector. The vector is then assigned to the variable “x” : 

```{r}
x <- c(10.4, 5.6, 3.1, 6.4, 21.7)
```

Assignment can also be made using the function assign(). An equivalent way of making
the same assignment as above is with:

```{r}
assign("x", c(10.4, 5.6, 3.1, 6.4, 21.7))
x
```

### Vector arithmetics R
Vectors can be used in arithmetic expressions, in which case the operations are performed element by element without having to write a for loop : 

```{r}
v <- 2*x + 1
v
```

### The "names" attribute
It is possible to give *names* to every element of a vector :

```{r}
names(v)<- c("meals","hotel","transport","souvenirs","varia")
v
```

and reference the elements later on using names :
```{r}
v["hotel"]
```


### Generating regular sequences
Try the following code to generate a regular sequence :

```{r}
seq(-5, 5) -> s3
```

and

```{r}
seq(-5, 5, by=.2) -> s3
```

To generate a sequence of a given number of elements, try :
```{r}
s4 <- seq(length=51, from=-5, by=.2)
s4
```

A related function is *rep()* which can be used for replicating an object in various complicated ways. The simplest form is :

```{r}
(s5 <- rep(x, times=5))
```

which will put five copies of x end-to-end in s5. Another useful version is :

```{r}
s6 <- rep(x, each=5)
s6
```

which repeats each element of x five times before moving on to the next.

## Logical vectors
Logical vectors are usually generated by logical tests. For example :

```{r}
c1 = x > 13
c2 = x > 13 & x< 4
class(c1)
c1
```

the newly created variable *c1* is of type **logical**. We can use logical variables to subset a variable :
```{r}
x[c1]
```

Only the elements of *x* where the corresponding element in *c1* is TRUE are matched.

| Operator        | Name           |
| ------------- |:-------------:|
| *<* | less than |
| *<=* | less than or equal to |
| *>* | greater than |
| *>=* | greater than or equal to |
| *==* | exact equality |
| *!=* | exact inequality |
| *!* | negation |
| *&* | AND |
| *\|* | OR |

As an example, if *c1* and *c2* are two logical variables, then following AND operation returns their intersection :
```{r eval=FALSE}
c2 & c1
```

while the following OR operation returns their union : 
```{r}
c1 | c2
```

The negation operator *!* would negate the elements of its input logical variable (FALSE would become *TRUE* and vice versa).

## Missing values
In some cases the components of a vector may not be completely known. When an element
or value is “not available” or a “missing value” in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general any operation on an *NA* becomes an *NA*. The motivation for this rule is simply that if the specification of an operation is incomplete, the result cannot be known and hence is not available.

The function *is.na()* gives a logical vector of the same size as x with value *TRUE* if and only if the corresponding element in x is *NA*.

```{r}
z <- c(1:3,NA); 
z
ind <- is.na(z)
```

Note that there is a second kind of “missing” values which are produced by numerical computation, the so-called *Not a Number*, *NaN*, values. Examples are :

```{r}
0/0
```

or

```{r}
Inf - Inf
```

which both give *NaN* since the result cannot be defined sensibly. The function *is.na()* is *TRUE* both for *NA* and *NaN* values. To differentiate these, *is.nan()* is only *TRUE* for an *NaN* :

```{r}
is.nan(NA)
is.nan(NaN)
```
## Working with characters
To assign a character to an object :

```{r}
a <- "Working with characters is possible in R"
```

The *paste()* function takes an arbitrary number of arguments and concatenates them one by one into character strings :

```{r}
labs <- paste(c("X","Y"), 1:13, sep="")
labs
```

## Variable Subsetting with Index vectors
Subsets of the elements of a vector may be selected by appending to the name of the vector an index vector in square brackets. More generally any expression that evaluates to a vector may  have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression. 

Such index vectors can be any of four distinct types.

### 1. Indexing with a logical vector. 
```{r}
x=c(1,2,NA,6,NA,923) 
y <- x[!is.na(x)] 
y 
```

### 2. Indexing with a vector of positive integral quantities. 
In this case the values in the index vector must lie in the set {1, 2, . . . , length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector. For example x[6] is the sixth component of x. Try :

```{r}
x[1:10]
```

selects the first 10 elements of x (assuming *length(x)* is not less than 10). With ghe following command one can generate a complex multiple combination of elements of x : 

```{r}
idx <- rep(c(1,2,2,1), times=2)
idx
c("x","y")[idx] 
```


### 3. Indexing with a vector of negative integral quantities
Such an index vector specifies the values to be excluded rather than included. Thus 

```{r}
y <- x[-(1:5)]
```

assigns all but the first five elements of *x* to *y*. 

### 4. Indexing with a vector of character strings
This possibility only applies where an object has a *names* attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above. 

```{r}
fruit <- c(5, 10, 1, 20) 
names(fruit) <- c("orange", "banana", "apple", "peach") 
fruit
lunch <- fruit[c("apple","orange")] 
```

The advantage is that alphanumeric names are often easier to remember than numeric indices. This option is particularly useful in connection with *data frames*, as we shall see later. 

## Using indexes to assign values to objects
An indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. The expression must be of the form *vector[index_vector]* as having an arbitrary expression in place of the vector name does not make much sense here. 

The vector assigned must match the length of the index vector, and in the case of a logical index vector it must again be the same length as the vector it is indexing. For example :

```{r}
x
x[is.na(x)] <- 0
x
```

replaces any missing values in *x* by zeros. On the other hand :

```{r}
y=c(1,-2,3,-4,5)
y[y < 0] <- -y[y < 0] 
```

has the same effect as using the *abs()* that computes the absolute values in a given variable :

```{r}
y <- abs(y)
```
 
