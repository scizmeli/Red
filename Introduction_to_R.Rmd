---
title: "Introduction to programming with R"
output: html_notebook
---

Servet Ahmet Çizmeli, [PranaGEO Ltd.](https://pranageo.com)

This tutorial has been compiled by slightly modifying a subset of the contents of the following documents : 

An Introduction to R http://cran.r-project.org/doc/manuals/R-intro.pdf
R Data Import/Export http://cran.r-project.org/doc/manuals/R-data.pdf
R Installation and Administration http://cran.r-project.org/doc/manuals/R-admin.pdf

## Getting help
R comes with extensive documentation. For example, to read the help of the function *lgamma*, type :

```{r}
help(lgamma)
```

or 

```{r}
?lgamma
```

On most R installations help is available in HTML format by running :

```{r}
help.start()
```

The vertical arrow keys on the keyboard ⇓⇑ can be used to scroll forward and backward through a command history.

## Basic tools to interact with R

### Current working directory
When we need to access files in the operating system's filesystem from R, the *current working directory* plays an important role. To get the current directory, use *getwd()*:
```{r}
getwd()
```

To change the current working directory, use *setwd()* :
```{r eval=FALSE}
setwd("some_sub_directory")
```

### Listing files
R will be able to find the files residing in the current directory without needing any additional path information. For example, all the files and directories listed with the below command are inside the current curking directory :

```{r}
#Let's create an empty text file on filesystem
file.create("test_file.txt")
```

The first variable to function *list.files()* is the directory to search under (here, the current working directory as denoted by "."). The second argument is the regular expressions (Regex) pattern for searching the file. For more information on Regex, refer to this course by [Gloria Li and Jenny Bryan](http://stat545.com/block022_regular-expression.html). Note that Regex is an advanced subject. If you are more comfortable with simple shell globing, you can use *glob2rx()* to search files whose names begin with *"test_"* :

```{r}
list.files(".", glob2rx("test_*"))
```

To obtain the size of the file in bytes, use the utility function "file.size()":
```{r}
file.size("test_file.txt")
```

**See Also :** *list.dirs()*, *dir()*

## Variables and native data types in R
The entities that R creates and manipulates are known as *variables* or *objects*. These may be variables, arrays of numbers, character strings, functions, or more general structures built from such components. During an R session, objects are created and stored by name inside the global environment. The R commands *objects()* and *ls()* save the same purpose of listing the name of variables available in the currently workspace : 

```{r}
a <- 1
objects()
```

The above command lists the objects currently stored in the memory of R (which is also called, workspace). To gather more information about an object, try to following utility functions : *dim()*, *names()*, *head()*, *tail()* and *summary()*. To remove objects from the memory (use with care, no recovery is possible if you don't have a backup), use the function *rm()* :

```{r}
rm(a)
ls()
```

## Native R data types
R supports the folowing native data types out of box : 

| Data Type        | Explanation | Examples |
| ------------- |:-------------:|:-------------:|
| *numeric* | Numeric values | c(12.3,1e5) |
| *character* | Strings  | "Hello world" |
| *factors* | Categorical Variables | as.factor("January","February","March") |
| *logical* | Binary values | c(TRUE,FALSE) |
| *list* | Numeric values | list(Name="John",age=12) |
| *matrix* | 2-d Matrix, same types | matrix(c(1,2,3,4),nrow = 2) |
| *data.frame* | 2-d Table, mixed types | data.frame(Name=c("John","Alice"),Age=c(12,14)) |
| *complex* | Complex numbers | 3 + 4i |

Note that the function *c()* produces a *vector*. In R, a vector is a one-dimensional list of values. One can put any type of data values together inside a vector. The only condition is that all the elements of the vector are of same type.

## Variable assignment
We previously saw that the function *c()* makes a concatenation of scalar numbers to form a vector. We can also assigned to the variable *x* using one of the following operators : *<-*, *->*, *=* :

```{r}
idx <- c(1,2,3,4,5,6,7,8,9)
summary(idx)
```

An assignment can also be made using the function *assign()*, offering an equivalent way where
the name of the target variable can be stored in another variable. This can be very useful for advanced programming :

```{r}
varname = "temp"
assign(varname, c(10.4, 5.6, 3.1, 6.4, 21.7))
temp
```

### Arithmetics with numeric vectors
Numeric Vectors can be used in arithmetic expressions, in which case the operations are performed element by element without having to write a for loop : 

```{r}
v <- 2*temp + 1
v
```

### Importing CSV data
To practice variaous R data types, let's use the [Maps That Changed Our World](https://www.arcgis.com/home/item.html?id=72f29810c72043358d7b2bad4c2f22c9) dataset to meet some of native data types. Let us have a look at the first 3 lines of the file :

```{r}
download.file("https://raw.githubusercontent.com/scizmeli/Red/master/MapsThatChangedOurWorld_StoryMap_Data.csv","MapsThatChangedOurWorld_StoryMap_Data.csv")
cat(readLines("MapsThatChangedOurWorld_StoryMap_Data.csv",n = 3), sep="\n") 
```

Inspecting the first three lines, we see that the columns of this csv dataset are separated by the character **";"** and the first line looks like it contains column headers. To import this csv file, we have several options. R comes with base tools that can read csv files : *read.csv()*, *read.table()*, *read.delim()*, *read.delim2()*, *data.table::fread()*. Note that the *fread()* function is part of package *data.table*. 

For this task, we will use *read.csv2()* :

```{r}
maps <- read.csv2("MapsThatChangedOurWorld_StoryMap_Data.csv",sep = ";")
maps
```

Note that we use the input argument *sep* to tell *read.csv2()* to use that character as a separator string. The resulting object *maps* is of type *data.frame*, which is the most popular data type in R. It stores data in a table structure, with multiple rows and columns. A *data.frame* gives the user ability to store different data types at each column. Each row and column can also have a name. In this dataset, each column has a name and the column names are stored in the first row of the csv file. 

Inspecting the generated *data.frame*, we can see that all the columns have been input as type *factor*. This reason for this is that the strings in an external data file are imported by default as *factor*. If  R can find any *numeric* type, it will recognize and assign a *numeric* column for it. The reason why columns *Latitude* and *Longitude* are first taken to be *character* is the presence of charactrers *E*, *W* and *N*, then converted to *factor* by *read.csv2()*. Also, the reason why the column **Year** is of type *character* is the presence of the string *AD* in the first line. We will have to process the data later on to obtain numeric variables inside these columns.

As stated above, the columns **Latitude** and **Longitude** in the sample *data.frame* are indeed meant to be numeric values. They are the geographical representation of latitude and longitude data where *N* denotes the northern hemisphere and *W* denotes the western hemisphere. In order to convert these columns to *numeric*, we need to take away these letters and make the eastern hemispherical longitudes negative.

```{r}
maps$Latitude <- gsub("N", "", maps$Latitude)
maps$Longitude <- gsub("W","", maps$Longitude)
index <- grep(" E", maps$Longitude)
maps$Longitude <- gsub("E","", maps$Longitude)

maps$Latitude <- as.numeric(maps$Latitude)
maps$Longitude <- as.numeric(maps$Longitude)
maps$Longitude[index] <- -1*maps$Longitude[index]
```

**Notes**

- We used function *gsub()* to search and replace a string in a vector of strings
- We used function *grep()* to return the position index of elements in a vector of strings that contain a search token (in this case the lines containing the token character *E*)
- We used the function *as.numeric()* to convert strings into numeric values.
- We multiplied the rows containing the teken character *E* by -1 to negate these values.

We also have to perform a similar operation on the Year column to make the column entirely numeric, i.e. *class(maps$Year)* becomes equal to *"numeric"*

```{r}
index2 <- grep("AD", maps$Year)
maps$Year <- gsub("AD","", maps$Year)
maps$Year <- as.numeric(maps$Year)
```

After these operations, we have purely numeric coordinate columns, with coordinates belonging to the Eastern hemisphere expressed as negatives :

```{r}
maps[,c("Longitude","Latitude","Year")]
```

The above notation took a 3-column subset of the original data.frame via column name selection.

### The "names" attribute
It is possible to give *names* to every element of a vector :

```{r}
names(v)<- c("meals","hotel","transport","souvenirs","varia")
v
```

and reference the elements later on using names :

```{r}
v["hotel"]
```

use the function *names()* to extract names in string format from a named vector :

```{r}
names(v)
```


### Generating regular sequences
Try the following code to generate a regular sequence with unit interval :

```{r}
seq(-5, 5) -> s3
```

using the *:* notation, we can produce the exact same result :

```{r}
all.equal(-5:5, s3)
```

To generate a sequence with other intervals, use the argument *by* :

```{r}
seq(-5, 5, by=.2) -> s3
```

To generate a sequence of a given number of elements, try :
```{r}
s4 <- seq(length=21, from=-5, by=.2)
s4
```

A related function is *rep()* which can be used for replicating an object in various complicated ways. The simplest form is :

```{r}
(s5 <- rep(c(1,2,-3), times=3))
```

which will put five copies of x end-to-end in s5. Another useful version is :

```{r}
s6 <- rep(c(1,2,-3), each=3)
s6
```

which repeats each element of x five times before moving on to the next.

## Logical vectors
Logical vectors are usually generated by logical tests. For example :

```{r}
c1 = temp > 13
c2 = temp > 13 & temp< 4
c1
```

the newly created variable *c1* is of type **logical** i.e. *class(c1)* is equal to *"`r class(c1)`"* . We can use logical variables to subset a variable :
```{r}
x[c1]
```

## Operators
Only the elements of *x* where the corresponding element in *c1* is TRUE are matched.

| Operator        | Name           |
| ------------- |:-------------:|
| *<* | less than |
| *<=* | less than or equal to |
| *>* | greater than |
| *>=* | greater than or equal to |
| *==* | exact equality |
| *!=* | exact inequality |
| *!* | negation |
| *&* | AND |
| *\|* | OR |

As an example, if *c1* and *c2* are two logical variables, then following AND operation returns their intersection :
```{r}
c2 & c1
```

while the following OR operation returns their union : 
```{r}
c1 | c2
```

The negation operator *!* would negate the elements of its input logical variable (FALSE would become *TRUE* and vice versa).

## Missing values
In some cases the components of a vector may not be completely known. When an element
or value is “not available” or a “missing value” in the statistical sense, a place within a vector may be reserved for it by assigning it the special value NA. In general any operation on an *NA* becomes an *NA*. The motivation for this rule is simply that if the specification of an operation is incomplete, the result cannot be known and hence is not available.

The function *is.na()* gives a logical vector of the same size as x with value *TRUE* if and only if the corresponding element in x is *NA*.

```{r}
z <- c(1:3,NA); 
z
ind <- is.na(z)
```

Note that there is a second kind of “missing” values which are produced by numerical computation, the so-called *Not a Number*, *NaN*, values. Examples are :

```{r}
0/0
```

or

```{r}
Inf - Inf
```

which both give *NaN* since the result cannot be defined sensibly. The function *is.na()* is *TRUE* both for *NA* and *NaN* values. To differentiate these, *is.nan()* is only *TRUE* for an *NaN* :

```{r}
is.nan(NA)
is.nan(NaN)
```

## Variable Subsetting with Index vectors
Subsets of the elements of a vector may be selected by appending to the name of the vector an index vector in square brackets. More generally any expression that evaluates to a vector may  have subsets of its elements similarly selected by appending an index vector in square brackets immediately after the expression. 

Such index vectors can be any of four distinct types.

### 1. Indexing with a logical vector. 
```{r}
x=c(1,2,NA,6,NA,923) 
y <- x[!is.na(x)] 
y 
```

### 2. Indexing with a vector of positive integral quantities. 
In this case the values in the index vector must lie in the set {1, 2, . . . , length(x)}. The corresponding elements of the vector are selected and concatenated, in that order, in the result. The index vector can be of any length and the result is of the same length as the index vector. For example x[6] is the sixth component of x. Try :

```{r}
x[1:10]
```

selects the first 10 elements of x (assuming *length(x)* is not less than 10). With ghe following command one can generate a complex multiple combination of elements of x : 

```{r}
var11 <- rep(c(1,2,2,1), times=2)
var11
c("x","y")[var11] 
```


### 3. Indexing with a vector of negative integral quantities
Such an index vector specifies the values to be excluded rather than included. Thus 

```{r}
y <- x[-(1:5)]
```

assigns all but the first five elements of *x* to *y*. 

### 4. Indexing with a vector of character strings
This possibility only applies where an object has a *names* attribute to identify its components. In this case a sub-vector of the names vector may be used in the same way as the positive integral labels in item 2 further above. 

```{r}
fruit <- c(5, 10, 1, 20) 
names(fruit) <- c("orange", "banana", "apple", "peach") 
fruit
lunch <- fruit[c("apple","orange")] 
```

The advantage is that alphanumeric names are often easier to remember than numeric indices. This option is particularly useful in connection with *data frames*, as we shall see later. 

## Using indexes to assign values to objects
An indexed expression can also appear on the receiving end of an assignment, in which case the assignment operation is performed only on those elements of the vector. The expression must be of the form *vector[index_vector]* as having an arbitrary expression in place of the vector name does not make much sense here. 

The vector assigned must match the length of the index vector, and in the case of a logical index vector it must again be the same length as the vector it is indexing. For example :

```{r}
x
x[is.na(x)] <- 0
x
```

replaces any missing values in *x* by zeros. On the other hand :

```{r}
y=c(1,-2,3,-4,5)
y[y < 0] <- -y[y < 0] 
```

has the same effect as using the *abs()* that computes the absolute values in a given variable :

```{r}
y <- abs(y)
```
 
## Working with characters
To assign a character to an object, use *"* or *'*:

```{r}
a <- "Working with characters is possible in R"
```

The *paste()* function takes an arbitrary number of arguments and concatenates them one by one into character strings :

```{r}
labs <- paste(c("X","Y"), 1:13, sep="")
labs
```
